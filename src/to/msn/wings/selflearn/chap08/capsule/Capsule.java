package to.msn.wings.selflearn.chap08.capsule;

public class Capsule {

	public static void main(String[] args) {
		/*アクセサーメソッド
		var p = new Person();
		p.setName("山田太郎");
		p.setAge(30);
		System.out.println(p.show());
		p.setAge(-30);
		*/
		
		var p = new Person("山田太郎", 30);
	    System.out.println(p.getName());

	}

}

/*
オブジェクト指向プログラミングを学ぶうえで「カプセル化」、「継承」、「ポリモーフィズム」といったキーワードは欠かせない。
「カプセル化（Encapsulation）」の基本は使い手に関係ないものは見せないである。
クラスで用意された機能のうち、利用するうえで知らなくても差し支えないものを隠してしまうと言い換えてもよい。

クラスの中で特定のメンバーを見せるかどうかを管理しているのは「アクセス修飾子」である。
○アクセス修飾子
|アクセス修飾子|概要|
|public        |すべてのクラスからアクセス可能|
|protected     |現在のクラスと派生クラス、同じパッケージのクラスからアクセス可能|
|なし          |現在のクラスと同じパッケージのクラスからアクセス可能|
|private       |現在のクラスからのみアクセス可能|
*/

/*
インスタンスフィールドは以下の理由から原則としてpublic宣言すべきではない。
1.読み書きの許可/禁止を制御できない
フィールドとはオブジェクトの状態を管理するための変数で、
その性質上、値の取得は許しても、変更にはなんらかの制限を課したい場合がほとんどである。
しかし、フィールドは単なる変数なので、アクセスの可否を求めるのはアクセス修飾子だけである。
アクセスを許可した時点でその値を取得/変更するのは利用者の自由である。
2.値の妥当性を検証できない
複数のメソッドから参照している場合、同様の検証ロジックがあちこちに散在しているのは、コードの保守性など望ましい状態ではない。
3.内部状態の変更に左右される
そもそもフィールドとは、オブジェクトの内部的な状態を表すもので、実装の変更によって将来的には内部的な値の持ち方も変化するかもしれない。
*/

/*
オブジェクトの内部状態（フィールド）は、外部からは直接にはアクセスできないようにして、
取得するにも変更するにもメソッドを介するべきである。
このような仕組みを実現するための手法を「アクセサーメソッド（Accessor Method）」という。
アクセサーメソッドではフィールドはprivate宣言しておいて、その読み書きにはアクセスのためのメソッドを利用する。

値取得のためのメソッドをゲッターメソッド、値設定のためのメソッドをセッターメソッドという。
一般的にアクセサーメソッドの名前はフィールド名の先頭は大文字にし、その前にget/setを付与する。
○ゲッター/セッター
public データ型 getフィールド名() {
  return this.フィールド名;
}
------------------------------
public void setフィールド名(データ型 引数) {
  this.フィールド名 = 引数;
}
*/

/*
オブジェクトを最初に生成したところから、一切の値（フィールド）が変化しないクラスのことを「不変クラス（不変型）」という。
可変クラスよりも実装/利用が簡単になり、結果としてバグの混入を防げる、堅牢なコードにもつながるというメリットにつながる。
クラスを設計する際には要件を満たす限り、不変クラスとするのが理想的である。

不変クラスでは、すべてのフィールドはprivate finalとして定義する（再代入を禁止する意図を明確に宣言できる）。
そして、これらのprivate finalフィールドを初期化するのは、コンストラクターの役割であり、その他には一切の変更メソッドは設けない。
また、一般的には、クラスそのものをfinal宣言し、拡張できないことを保証する。継承先のクラスが不変性を破るのを防止している。
*/
