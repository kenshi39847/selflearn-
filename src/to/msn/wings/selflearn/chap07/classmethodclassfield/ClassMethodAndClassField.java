package to.msn.wings.selflearn.chap07.classmethodclassfield;

public class ClassMethodAndClassField {
	
	public static void main(String[] args) {
		
		/*クラスメソッド
		System.out.println(Figure.getTriangleArea(10, 20));
		*/
		
		/*クラスフィールド
		System.out.println(Figure.pi);
		Figure.getCircleArea(5);
		*/
		
		/*クラス定数
		System.out.println(MyApp.BOOK_TITLE);
		//MyApp.BOOK_TITLE = "本気でおぼえるJava";  //エラー：finalフィールドMyApp.BOOK_TITLEには代入できません
		*/
		
		/*インスタンス単位の定数
		var app1 = new MyApp("独習Java");
		System.out.println(app1.APP_NAME);
		var app2 = new MyApp("Teach Yourself Java");
		System.out.println(app2.APP_NAME);
		*/

	}

}

/*
クラスから直接呼び出せる（=インスタンスを生成しなくてもよい）メソッド/フィールドのことを「クラスメソッド/クラスフィールド」という。
静的メソッド/静的フィールドまたはstaticメソッド/staticフィールドとも呼ばれる。
インスタンスメンバーはインスタンスそれぞれが独立した実態（値）を持つのに対して、
クラスメンバーはクラスで1つだけの存在であり、すべてのインスタンスで共有される。

クラスメソッドを定義するするには、メソッド定義にstatic修飾子を付与するだけである。

○クラスメソッドの注意点
1.クラスメソッドでは変数thisは使えない
thisは現在のインスタンスを参照するための変数であり、クラスメソッドではインスタンスそのものが作られていないので、
thisキーワードも使用できない。言い換えるとクラスメソッドからインスタンスメソッド/インスタンスフィールドは参照できない。
2.クラスメソッドはオブジェクト経由では呼び出さない
クラスメソッドはインスタンス経由で呼び出すことも可能だが、クラスメソッドへのアクセスのためにインスタンスを生成するのは
無駄であり、staticであることが不明瞭にもなるので、避けるようにする。

クラスによってはクラスメンバーしか持たないものもある。
例えば、標準ライブラリであればMathクラスが代表的な例である。
絶対値、平方根、三角関数といった標準的な数学処理をクラスメソッドとして1つのクラスで束ねている。
このようなクラスのことを「ユーティリティクラス」という。
ユーティリティクラスではインスタンス化は不要で、無駄なインスタンスだけを生成できてしまう状態はよろしくない。
そのような場合は、コンストラクターをprivate化することで、そのクラスのインスタンス化を禁止できる。
public final class Math {
  private Math() {}
  ...中略...
}
Mathクラスをインスタンス化しようとすると、「コンストラクターMath()は不可視です」というエラーが起きる。
*/


/*
クラスフィールドもクラスメソッドと同様、フィールドに対してstatic修飾子を付与するだけで定義できる。
また、クラスフィールドはオブジェクトに属するインスタンスフィールド異なり、クラスに属するため、クラスメソッドからもアクセスできる。
ただし、クラスフィールドを利用するケースはあまりない。なぜなら、クラスに属するクラスフィールドは、
インスタンスフィールドとは異なり、その内容を変更した場合、関係するすべてのコード（インスタンス）に影響が及んでしまうからである。
原則として、クラスフィールドの利用は、
・読み取り専用
・クラス自体の状態を監視する
というごく限定された状況に留めるべきである。

public class MySingleton {
  private static MySingleton instance = new MySingleton();
  private MySingleton() {}
  //あらかじめ用意しておいたインスタンスを取得
  public static MySingleton getInstance() {
    return instance;
  }
}
上記は「シングルトン(Singleton)パターン」と呼ばれるデザインパターンの一種で、
クラスのインスタンスを1つしか生成しない、また、したくないという状況で利用する。
シングルトンパターンではコンストラクターをprivate宣言し、アプリで保持すべき唯一のインスタンスをクラスフィールドとして保持しておく。
これによって、クラスがロードされた初回に一度だけインスタンスが生成され、以降のインスタンス生成はしなく（できなく）なる。
*/


/*
class{...}直下で定義された定数、読み取り専用のフィールドのことを「クラス定数」という。
クラス定数を表すにはfinal修飾子を付与すればよい。
○クラス定数
[アクセス修飾子] static final データ型 定数名 [=値];

static修飾子を伴わない、いわゆる「インスタンス単位の定数」を定義することもできる
○インスタンス定数
[アクセス修飾子] final データ型 定数名;
この場合、定数値はコンストラクター経由で渡すのが一般的である。基本はクラス定数とし、理由があるときのみ非staticを使用する。
*/

/*
初期化ブロックのstatic版を「static初期化ブロック（staticイニシャライザー）」という。
初期化ブロックがインスタンスを生成する際に実行されるのに対し、
static初期化ブロックはクラスが初期化される際に実行される。
○static初期化ブロック
static {
  ...初期化のためのコード...
}

static初期化ブロックはクラスメンバーを初期化するのに利用するのが一般的である。
例）
public class Initializer {
  public static final String DOG;
  public static final String CAT;
  public static final String MOUSE;
  static {
    DOG = "いぬ";
    CAT = "ねこ";
    MOUSE = "ねずみ";
  }
}
定数はコンパイル時に、参照元のクラスにコピーされ、その性質上以下のような問題が発生する。
・値を修正したときに、定数を参照しているクラスも再コンパイルが必要
・参照元クラスのサイズがわずかながら大きくなる
しかし、定数をstatic初期化ブロックで初期化することで、定数値をコピーできなくなるので、上記のような問題はなくなる。
*/
